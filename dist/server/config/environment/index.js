/**
 * Created by Justin on 9/2/16.
 */
"use strict";
/// <reference path="../../interfaces/extensions/Node.d.ts" />
// $log exists on NodeJs.Global, but our GlobalConfig may not have been called yet
// Instantiate Logger here so we can use it
// TODO: ensure GlobalConfig() fires before this file is imported
const ts_log_debug_1 = require('ts-log-debug');
const $log = new ts_log_debug_1.Logger();
/**
 * This file exports environment configurations based on process.env.NODE_ENV
 * TODO: should we have an interface for this type?
 */
// Require local config file if it exists, or create a replacement with `use` set to false
let localConfig = { use: false }, devConfig = require('./development'), testConfig = require('./test'), prodConfig = require('./production'), sharedConfig = require('./all'), _ = require('lodash');
const env = process.env.NODE_ENV || 'development';
if (env === 'development') {
    try {
        localConfig = require('./local');
    }
    catch (e) {
        $log.warn('No local config file found - using development config');
    }
}
// Export either local or development config if NODE_ENV === 'development', test config if NODE_ENV === 'test'
// or production config otherwise
let dynamic = {};
// There are way less verbose ways of writing this logic, but Webstorm can't handle dynamic paths
// in `require()` statements. This ensures that the IDE recognizes all the properties in our config object
if (env === 'development') {
    dynamic = localConfig.use ? localConfig : devConfig;
}
else if (env === 'test') {
    dynamic = testConfig;
}
else {
    dynamic = prodConfig;
}
exports.CONFIG = _.merge(dynamic, sharedConfig);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbmZpZy9lbnZpcm9ubWVudC9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7R0FFRzs7QUFFSCw4REFBOEQ7QUFFOUQsa0ZBQWtGO0FBQ2xGLDJDQUEyQztBQUMzQyxpRUFBaUU7QUFDakUsK0JBQXVCLGNBQ3ZCLENBQUMsQ0FEb0M7QUFDckMsTUFBTSxJQUFJLEdBQUcsSUFBSSxxQkFBTSxFQUFFLENBQUM7QUFFMUI7OztHQUdHO0FBRUgsMEZBQTBGO0FBQzFGLElBQUksV0FBVyxHQUFPLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxFQUNuQyxTQUFTLEdBQU8sT0FBTyxDQUFDLGVBQWUsQ0FBQyxFQUN4QyxVQUFVLEdBQU8sT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUNsQyxVQUFVLEdBQU8sT0FBTyxDQUFDLGNBQWMsQ0FBQyxFQUN4QyxZQUFZLEdBQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUNuQyxDQUFDLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBRXZCLE1BQU0sR0FBRyxHQUFVLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxJQUFJLGFBQWEsQ0FBQztBQUV6RCxFQUFFLENBQUMsQ0FBQyxHQUFHLEtBQUssYUFBYSxDQUFDLENBQzFCLENBQUM7SUFDQSxJQUNBLENBQUM7UUFDQSxXQUFXLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ2xDLENBQ0E7SUFBQSxLQUFLLENBQUEsQ0FBQyxDQUFDLENBQUMsQ0FDUixDQUFDO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7QUFDRixDQUFDO0FBRUQsOEdBQThHO0FBQzlHLGlDQUFpQztBQUNqQyxJQUFJLE9BQU8sR0FBUSxFQUFFLENBQUM7QUFFdEIsaUdBQWlHO0FBQ2pHLDBHQUEwRztBQUMxRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEtBQUssYUFBYSxDQUFDLENBQzFCLENBQUM7SUFDQSxPQUFPLEdBQUcsV0FBVyxDQUFDLEdBQUcsR0FBRyxXQUFXLEdBQUcsU0FBUyxDQUFDO0FBQ3JELENBQUM7QUFDRCxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxLQUFLLE1BQU0sQ0FBQyxDQUN4QixDQUFDO0lBQ0EsT0FBTyxHQUFHLFVBQVUsQ0FBQztBQUN0QixDQUFDO0FBQ0QsSUFBSSxDQUNKLENBQUM7SUFDQSxPQUFPLEdBQUcsVUFBVSxDQUFDO0FBQ3RCLENBQUM7QUFFWSxjQUFNLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUMiLCJmaWxlIjoiY29uZmlnL2Vudmlyb25tZW50L2luZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGVkIGJ5IEp1c3RpbiBvbiA5LzIvMTYuXG4gKi9cblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL2ludGVyZmFjZXMvZXh0ZW5zaW9ucy9Ob2RlLmQudHNcIiAvPlxuXG4vLyAkbG9nIGV4aXN0cyBvbiBOb2RlSnMuR2xvYmFsLCBidXQgb3VyIEdsb2JhbENvbmZpZyBtYXkgbm90IGhhdmUgYmVlbiBjYWxsZWQgeWV0XG4vLyBJbnN0YW50aWF0ZSBMb2dnZXIgaGVyZSBzbyB3ZSBjYW4gdXNlIGl0XG4vLyBUT0RPOiBlbnN1cmUgR2xvYmFsQ29uZmlnKCkgZmlyZXMgYmVmb3JlIHRoaXMgZmlsZSBpcyBpbXBvcnRlZFxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAndHMtbG9nLWRlYnVnJ1xuY29uc3QgJGxvZyA9IG5ldyBMb2dnZXIoKTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgZXhwb3J0cyBlbnZpcm9ubWVudCBjb25maWd1cmF0aW9ucyBiYXNlZCBvbiBwcm9jZXNzLmVudi5OT0RFX0VOVlxuICogVE9ETzogc2hvdWxkIHdlIGhhdmUgYW4gaW50ZXJmYWNlIGZvciB0aGlzIHR5cGU/XG4gKi9cblxuLy8gUmVxdWlyZSBsb2NhbCBjb25maWcgZmlsZSBpZiBpdCBleGlzdHMsIG9yIGNyZWF0ZSBhIHJlcGxhY2VtZW50IHdpdGggYHVzZWAgc2V0IHRvIGZhbHNlXG5sZXQgbG9jYWxDb25maWc6YW55ID0geyB1c2U6IGZhbHNlIH0sXG5cdGRldkNvbmZpZzphbnkgPSByZXF1aXJlKCcuL2RldmVsb3BtZW50JyksXG5cdHRlc3RDb25maWc6YW55ID0gcmVxdWlyZSgnLi90ZXN0JyksXG5cdHByb2RDb25maWc6YW55ID0gcmVxdWlyZSgnLi9wcm9kdWN0aW9uJyksXG5cdHNoYXJlZENvbmZpZzphbnkgPSByZXF1aXJlKCcuL2FsbCcpLFxuXHRfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbmNvbnN0IGVudjpzdHJpbmcgPSBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAnZGV2ZWxvcG1lbnQnO1xuXG5pZiAoZW52ID09PSAnZGV2ZWxvcG1lbnQnKVxue1xuXHR0cnlcblx0e1xuXHRcdGxvY2FsQ29uZmlnID0gcmVxdWlyZSgnLi9sb2NhbCcpO1xuXHR9XG5cdGNhdGNoKGUpXG5cdHtcblx0XHQkbG9nLndhcm4oJ05vIGxvY2FsIGNvbmZpZyBmaWxlIGZvdW5kIC0gdXNpbmcgZGV2ZWxvcG1lbnQgY29uZmlnJyk7XG5cdH1cbn1cblxuLy8gRXhwb3J0IGVpdGhlciBsb2NhbCBvciBkZXZlbG9wbWVudCBjb25maWcgaWYgTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcsIHRlc3QgY29uZmlnIGlmIE5PREVfRU5WID09PSAndGVzdCdcbi8vIG9yIHByb2R1Y3Rpb24gY29uZmlnIG90aGVyd2lzZVxubGV0IGR5bmFtaWMgPSA8YW55Pnt9O1xuXG4vLyBUaGVyZSBhcmUgd2F5IGxlc3MgdmVyYm9zZSB3YXlzIG9mIHdyaXRpbmcgdGhpcyBsb2dpYywgYnV0IFdlYnN0b3JtIGNhbid0IGhhbmRsZSBkeW5hbWljIHBhdGhzXG4vLyBpbiBgcmVxdWlyZSgpYCBzdGF0ZW1lbnRzLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgSURFIHJlY29nbml6ZXMgYWxsIHRoZSBwcm9wZXJ0aWVzIGluIG91ciBjb25maWcgb2JqZWN0XG5pZiAoZW52ID09PSAnZGV2ZWxvcG1lbnQnKVxue1xuXHRkeW5hbWljID0gbG9jYWxDb25maWcudXNlID8gbG9jYWxDb25maWcgOiBkZXZDb25maWc7XG59XG5lbHNlIGlmIChlbnYgPT09ICd0ZXN0Jylcbntcblx0ZHluYW1pYyA9IHRlc3RDb25maWc7XG59XG5lbHNlXG57XG5cdGR5bmFtaWMgPSBwcm9kQ29uZmlnO1xufVxuXG5leHBvcnQgY29uc3QgQ09ORklHID0gXy5tZXJnZShkeW5hbWljLCBzaGFyZWRDb25maWcpO1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
