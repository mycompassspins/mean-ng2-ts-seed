/**
 * Created by Justin on 9/2/16.
 */
"use strict";
/// <reference path="../../interfaces/extensions/Node.d.ts" />
const Logger_1 = require('../../helpers/Logger');
/**
 * This file exports environment configurations based on process.env.NODE_ENV
 * TODO: should we have an interface for this type?
 */
// Require local config file if it exists, or create a replacement with `use` set to false
let localConfig = { use: false }, devConfig = require('./development'), testConfig = require('./test'), prodConfig = require('./production'), sharedConfig = require('./all'), _ = require('lodash');
const env = process.env.NODE_ENV || 'development';
if (env === 'development') {
    try {
        localConfig = require('./local');
    }
    catch (e) {
        Logger_1.$log.warn('No local config file found - using development config');
    }
}
// Export either local or development config if NODE_ENV === 'development', test config if NODE_ENV === 'test'
// or production config otherwise
let dynamic = {};
// There are way less verbose ways of writing this logic, but Webstorm can't handle dynamic paths
// in `require()` statements. This ensures that the IDE recognizes all the properties in our config object
if (env === 'development') {
    dynamic = localConfig.use ? localConfig : devConfig;
}
else if (env === 'test') {
    dynamic = testConfig;
}
else {
    dynamic = prodConfig;
}
exports.CONFIG = _.merge(dynamic, sharedConfig);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbmZpZy9lbnZpcm9ubWVudC9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7R0FFRzs7QUFFSCw4REFBOEQ7QUFFOUQseUJBQXFCLHNCQVFyQixDQUFDLENBUjBDO0FBRTNDOzs7R0FHRztBQUVILDBGQUEwRjtBQUMxRixJQUFJLFdBQVcsR0FBTyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsRUFDbkMsU0FBUyxHQUFPLE9BQU8sQ0FBQyxlQUFlLENBQUMsRUFDeEMsVUFBVSxHQUFPLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFDbEMsVUFBVSxHQUFPLE9BQU8sQ0FBQyxjQUFjLENBQUMsRUFDeEMsWUFBWSxHQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFDbkMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUV2QixNQUFNLEdBQUcsR0FBVSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsSUFBSSxhQUFhLENBQUM7QUFFekQsRUFBRSxDQUFDLENBQUMsR0FBRyxLQUFLLGFBQWEsQ0FBQyxDQUMxQixDQUFDO0lBQ0EsSUFDQSxDQUFDO1FBQ0EsV0FBVyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNsQyxDQUNBO0lBQUEsS0FBSyxDQUFBLENBQUMsQ0FBQyxDQUFDLENBQ1IsQ0FBQztRQUNBLGFBQUksQ0FBQyxJQUFJLENBQUMsdURBQXVELENBQUMsQ0FBQztJQUNwRSxDQUFDO0FBQ0YsQ0FBQztBQUVELDhHQUE4RztBQUM5RyxpQ0FBaUM7QUFDakMsSUFBSSxPQUFPLEdBQVEsRUFBRSxDQUFDO0FBRXRCLGlHQUFpRztBQUNqRywwR0FBMEc7QUFDMUcsRUFBRSxDQUFDLENBQUMsR0FBRyxLQUFLLGFBQWEsQ0FBQyxDQUMxQixDQUFDO0lBQ0EsT0FBTyxHQUFHLFdBQVcsQ0FBQyxHQUFHLEdBQUcsV0FBVyxHQUFHLFNBQVMsQ0FBQztBQUNyRCxDQUFDO0FBQ0QsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsS0FBSyxNQUFNLENBQUMsQ0FDeEIsQ0FBQztJQUNBLE9BQU8sR0FBRyxVQUFVLENBQUM7QUFDdEIsQ0FBQztBQUNELElBQUksQ0FDSixDQUFDO0lBQ0EsT0FBTyxHQUFHLFVBQVUsQ0FBQztBQUN0QixDQUFDO0FBRVksY0FBTSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxDQUFDIiwiZmlsZSI6ImNvbmZpZy9lbnZpcm9ubWVudC9pbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JlYXRlZCBieSBKdXN0aW4gb24gOS8yLzE2LlxuICovXG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi9pbnRlcmZhY2VzL2V4dGVuc2lvbnMvTm9kZS5kLnRzXCIgLz5cblxuaW1wb3J0IHsgJGxvZyB9IGZyb20gJy4uLy4uL2hlbHBlcnMvTG9nZ2VyJ1xuXG4vKipcbiAqIFRoaXMgZmlsZSBleHBvcnRzIGVudmlyb25tZW50IGNvbmZpZ3VyYXRpb25zIGJhc2VkIG9uIHByb2Nlc3MuZW52Lk5PREVfRU5WXG4gKiBUT0RPOiBzaG91bGQgd2UgaGF2ZSBhbiBpbnRlcmZhY2UgZm9yIHRoaXMgdHlwZT9cbiAqL1xuXG4vLyBSZXF1aXJlIGxvY2FsIGNvbmZpZyBmaWxlIGlmIGl0IGV4aXN0cywgb3IgY3JlYXRlIGEgcmVwbGFjZW1lbnQgd2l0aCBgdXNlYCBzZXQgdG8gZmFsc2VcbmxldCBsb2NhbENvbmZpZzphbnkgPSB7IHVzZTogZmFsc2UgfSxcblx0ZGV2Q29uZmlnOmFueSA9IHJlcXVpcmUoJy4vZGV2ZWxvcG1lbnQnKSxcblx0dGVzdENvbmZpZzphbnkgPSByZXF1aXJlKCcuL3Rlc3QnKSxcblx0cHJvZENvbmZpZzphbnkgPSByZXF1aXJlKCcuL3Byb2R1Y3Rpb24nKSxcblx0c2hhcmVkQ29uZmlnOmFueSA9IHJlcXVpcmUoJy4vYWxsJyksXG5cdF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuY29uc3QgZW52OnN0cmluZyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WIHx8ICdkZXZlbG9wbWVudCc7XG5cbmlmIChlbnYgPT09ICdkZXZlbG9wbWVudCcpXG57XG5cdHRyeVxuXHR7XG5cdFx0bG9jYWxDb25maWcgPSByZXF1aXJlKCcuL2xvY2FsJyk7XG5cdH1cblx0Y2F0Y2goZSlcblx0e1xuXHRcdCRsb2cud2FybignTm8gbG9jYWwgY29uZmlnIGZpbGUgZm91bmQgLSB1c2luZyBkZXZlbG9wbWVudCBjb25maWcnKTtcblx0fVxufVxuXG4vLyBFeHBvcnQgZWl0aGVyIGxvY2FsIG9yIGRldmVsb3BtZW50IGNvbmZpZyBpZiBOT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JywgdGVzdCBjb25maWcgaWYgTk9ERV9FTlYgPT09ICd0ZXN0J1xuLy8gb3IgcHJvZHVjdGlvbiBjb25maWcgb3RoZXJ3aXNlXG5sZXQgZHluYW1pYyA9IDxhbnk+e307XG5cbi8vIFRoZXJlIGFyZSB3YXkgbGVzcyB2ZXJib3NlIHdheXMgb2Ygd3JpdGluZyB0aGlzIGxvZ2ljLCBidXQgV2Vic3Rvcm0gY2FuJ3QgaGFuZGxlIGR5bmFtaWMgcGF0aHNcbi8vIGluIGByZXF1aXJlKClgIHN0YXRlbWVudHMuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBJREUgcmVjb2duaXplcyBhbGwgdGhlIHByb3BlcnRpZXMgaW4gb3VyIGNvbmZpZyBvYmplY3RcbmlmIChlbnYgPT09ICdkZXZlbG9wbWVudCcpXG57XG5cdGR5bmFtaWMgPSBsb2NhbENvbmZpZy51c2UgPyBsb2NhbENvbmZpZyA6IGRldkNvbmZpZztcbn1cbmVsc2UgaWYgKGVudiA9PT0gJ3Rlc3QnKVxue1xuXHRkeW5hbWljID0gdGVzdENvbmZpZztcbn1cbmVsc2Vcbntcblx0ZHluYW1pYyA9IHByb2RDb25maWc7XG59XG5cbmV4cG9ydCBjb25zdCBDT05GSUcgPSBfLm1lcmdlKGR5bmFtaWMsIHNoYXJlZENvbmZpZyk7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
